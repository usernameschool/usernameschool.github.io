<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		 <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

		<title>Модульное программирование</title>

		<!-- Google font -->
		<link href="https://fonts.googleapis.com/css?family=Lato:700%7CMontserrat:400,600" rel="stylesheet">

		<!-- Bootstrap -->
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css"/>

		<!-- Font Awesome Icon -->
		<link rel="stylesheet" href="css/font-awesome.min.css">

		<!-- Custom stlylesheet -->
		<link type="text/css" rel="stylesheet" href="css/style.css"/>

		<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
		<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
		<!--[if lt IE 9]>
		  <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
		  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
		<![endif]-->

    </head>
	<body>

		<!-- Header -->
		<header id="header">
			<div class="container">

				<div class="navbar-header">
					<!-- Logo -->
					<div class="navbar-brand">
						<a class="logo" href="index.html">
							<img src="./img/logo.png" alt="logo">
						</a>
					</div>
					<!-- /Logo -->

					<!-- Mobile toggle -->
					<button class="navbar-toggle">
						<span></span>
					</button>
					<!-- /Mobile toggle -->
				</div>

				<nav id="nav">
					<ul class="main-menu nav navbar-nav navbar-right">
						<li><a href="index.html">Главная</a></li>
						<li><a href="#anchor">Содержание курса</a></li>
					</ul>
				</nav>

			</div>
		</header>
		<!-- /Header -->

		<!-- Hero-area -->
		<div class="hero-area section">

			<!-- Backgound Image -->
			<div class="bg-image bg-parallax overlay" style="background-image:url(./img/blog-post-background.jpg)"></div>
			<!-- /Backgound Image -->

			<div class="container">
				<div class="row">
					<div class="col-md-10 col-md-offset-1 text-center">
						
						<h1 class="white-text">Модульное программирование</h1>
						
					</div>
				</div>
			</div>

		</div>
		<!-- /Hero-area -->

		<!-- Blog -->
		<div id="blog" class="section">

			<!-- container -->
			<div class="container">

				<!-- row -->
				<div class="row">

					<!-- main blog -->
					<div id="main" class="col-md-12">
						<ul class="nav nav-tabs">
  <li class="active"><a data-toggle="tab" href="#panel1">Теория</a></li>
  <li><a data-toggle="tab" href="#panel2">Практика</a></li>
</ul>
 
<div class="tab-content">
  <div id="panel1" class="tab-pane fade in active">
    
    <p><div class="blog-post">
							<p>Модульное программирование является особым способом разработки программы, которая строится при этом из нескольких относительно независимых друг от друга частей – <i>модулей</i>. Понятие модуля является одним из центральных при разработке программного обеспечения.</p>
<p><b>Модуль</b> — функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной её части, предназначенный для использования в других программах. Модули позволяют разбивать сложные задачи на более мелкие в соответствии с принципом модульности. Обычно проектируются таким образом, чтобы предоставлять программистам удобную для многократного использования функциональность (интерфейс) в виде набора функций, классов, констант. Модули могут объединяться в пакеты и, далее, в библиотеки. Удобство использования модульной архитектуры заключается в возможности обновления (замены) модуля, без необходимости изменения остальной системы. В большинстве случаев различные модули могут запускаться как на одном сервере, так и на разных, для распределения нагрузки и создания распределенной архитектуры.</p>
<p><b><i>Модульное программирование</i></b> — это организация программы как совокупности небольших независимых блоков, называемых модулями, структура и поведение которых подчиняются определенным правилам. Использование модульного программирования позволяет упростить тестирование программы и обнаружение ошибок. Аппаратно-зависимые подзадачи могут быть строго отделены от других подзадач, что улучшает мобильность создаваемых программ.</p>
<p>Суть <b>модульного программирования</b> состоит в разбиении сложной задачи на некоторое число более простых подзадач и составлении программ для решения достаточно независимо друг от друга. Модульность является одним из основных принципов построения программных проектов.</p>
<p>Языки программирования, поддерживающие модульный подход, описывают модуль как программную единицу, состоящую из двух основных частей - спецификации (интерфейса) и реализации. В спецификации приводятся такие характеристики объектов модуля, которые необходимы и достаточны для использования этих объектов в других модулях и программах. Это позволяет использовать объекты модулей только на основе информации об их интерфейсе (не ожидая их полного описания). В реализационной части модуля описывается представление и алгоритмы обработки, связанные с теми или иными объектами модуля.</p>
<p>Модуль является одним из средств, облегчающих верификацию программ. Модуль, как средство создания абстракции, выделяет спецификацию и локализует сведения о реализации.</p>
<p>Модули служат также целям создания проблемно-ориентированного контекста и локализации машинной зависимости.</p>
<p><b><i>Концепция модульного программирования</i></b></p>
<p>Концепцию модульного программирования можно сформулировать в виде нескольких понятий и положений:</p>
<p>·<mark>Функциональная декомпозиция задачи</mark>- разбиение большой задачи на ряд более мелких, функционально самостоятельных подзадач - модулей. Модули связаны между собой только по входным и выходным данным.</p>
<p>·<mark>Модуль</mark> - основа концепции модульного программирования. Каждый модуль в функциональной декомпозиции представляет собой &quot;черный ящик&quot; с одним входом и одним выходом. Модульный подход позволяет безболезненно производить модернизацию программы в процессе ее эксплуатации и облегчает ее сопровождение. Дополнительно модульный подход позволяет разрабатывать части программ одного проекта на разных языках программирования, после чего с помощью компоновочных средств объединять их в единый загрузочный модуль.</p>
<p>·<mark>Реализуемые решения должны быть простыми и ясными</mark>. Если назначение модуля непонятно, то это говорит о том, что декомпозиция начальной или промежуточной задачи была проведена недостаточно качественно. В этом случае необходимо еще раз проанализировать задачу и, возможно, провести дополнительное разбиение на подзадачи. При наличии сложных мест в проекте, их нужно подробнее документировать с помощью продуманной системы комментариев. Этот процесс нужно продолжать до тех пор, пока действительно не удастся добиться ясного понимания назначения всех модулей задачи и их оптимального сочетания.</p>
<p>Назначение всех переменных модуля должно быть описано с помощью комментариев по мере их определения.</p>
<p><b>Структурное программирование </b>— методология разработки программного обеспечения, в основе которой лежит представление программы в виде иерархической структуры блоков. Предложена в 70-х годах XX века Э. Дейкстрой, разработана и дополнена Н. Виртом.</p>
<p>В соответствии с данной методологией:</p>
<ol>
	<li>Любая программа представляет собой структуру, построенную из трёх типов базовых конструкций:</li>
</ol>
<p>-<b>Последовательное исполнение </b>— однократное выполнение операций в том порядке, в котором они записаны в тексте программы;</p>
<p>-<b>Ветвление </b>— однократное выполнение одной из двух или более операций, в зависимости от выполнения некоторого заданного условия;</p>
<p>-<b>Цикл</b>— многократное исполнение одной и той же операции до тех пор, пока выполняется некоторое заданное условие (условие продолжения цикла).</p>
<p>В программе базовые конструкции могут быть вложены друг в друга произвольным образом, но никаких других средств управления последовательностью выполнения операций не предусматривается.</p>
<ol>
	<li>Повторяющиеся фрагменты программы (либо не повторяющиеся, но представляющие собой логически целостные вычислительные блоки) могут оформляться в виде т. н. подпрограмм (процедур или функций). В этом случае в тексте основной программы, вместо помещённого в подпрограмму фрагмента, вставляется инструкция <b>вызова подпрограммы</b>. При выполнении такой инструкции выполняется вызванная подпрограмма, после чего исполнение программы продолжается с инструкции, следующей за командой вызова подпрограммы.</li>
	<li>Нисходящий подход к разработке программ.</li>
</ol>
<p>Разработка программы ведётся пошагово, методом «сверху вниз».</p>
<p>Сначала пишется текст основной программы, в котором, вместо каждого связного логического фрагмента текста, вставляется вызов подпрограммы, которая будет выполнять этот фрагмент. Вместо настоящих, работающих подпрограмм, в программу вставляются «заглушки», которые ничего не делают. Полученная программа проверяется и отлаживается. После того, как программист убедится, что подпрограммы вызываются в правильной последовательности (то есть общая структура программы верна), подпрограммы-заглушки последовательно заменяются на реально работающие, причём разработка каждой подпрограммы ведётся тем же методом, что и основной программы. Разработка заканчивается тогда, когда не останется ни одной «затычки», которая не была бы удалена. Такая последовательность гарантирует, что на каждом этапе разработки программист одновременно имеет дело с обозримым и понятным ему множеством фрагментов, и может быть уверен, что общая структура всех более высоких уровней программы верна. При сопровождении и внесении изменений в программу выясняется, в какие именно процедуры нужно внести изменения, и они вносятся, не затрагивая части программы, непосредственно не связанные с ними. Это позволяет гарантировать, что при внесении изменений и исправлении ошибок не выйдет из строя какая-то часть программы, находящаяся в данный момент вне зоны внимания программиста.</p>
<ol>
	<li>Восходящий подход к разработке программ.</li>
</ol>
<p>В этом случае осуществляется последовательное построение программы из уже имеющихся элементов, начиная с примитивов, предоставляемых выбранным языком программирования. Этот процесс заканчивается получением требуемой готовой программы. На каждом этапе из имеющихся элементов строятся более мощные элементы. Эти элементы будут использоваться на следующем этапе для построения еще более мощных элементов, и так далее до тех пор, пока не будут получены элементы, из которых можно непосредственно составить требуемую программу.</p>
<p>На практике восходящая разработка в чистом виде также как и нисходящая невозможна. Построение каждого нового элемента должно сопровождаться просмотром вперед с целью проверки, удовлетворяет ли он требованиям к разрабатываемой программе; но даже и при таком подходе на более позднем этапе часто обнаруживается, что использованная ранее последовательность построения была выбрана неправильно и требуется новая итерация.</p>
<p>При конструировании новых алгоритмов обычно доминирует нисходящий метод. При адаптации программ к несколько измененным требованиям предпочтение зачастую отдается восходящему методу. Оба этих метода позволяют разрабатывать <i>структурированные </i>программы.</p>
<p><b>Теорема о структурном программировании</b></p>
<p>Любую схему алгоритма можно представить в виде композиции вложенных блоков begin и end, условных операторов if, then, else, циклов с предусловием (while) и может быть дополнительных логических переменных (флагов).</p>
<p>Эта теорема была сформулирована итальянскими математиками К. Бомом и Дж. Якопини в 1966 году и говорит нам о том, как можно избежать использования оператора перехода goto.</p>
<p>Достоинства структурного программирования:</p>
<ol>
	<li>Структурное программирование позволяет значительно сократить число вариантов построения программы по одной и той же спецификации, что значительно снижает сложность программы и, что ещё важнее, облегчает понимание её другими разработчиками.</li>
	<li>В структурированных программах логически связанные операторы находятся визуально ближе, а слабо связанные — дальше, что позволяет обходиться без блок-схем и других графических форм изображения алгоритмов (по сути, сама программа является собственной блок-схемой).</li>
	<li>Сильно упрощается процесс тестирования и отладки структурированных программ.</li>
</ol>

<p><strong>Объектно-ориентированное программирование</strong> (сокращенно ООП) является методом программирования, имитирующим то, как человек выполняет какую-либо работу. Объектно-ориентированное программирование - результат естественной эволюции более ранних методологий программирования: оно более структурировано и более модульное и абстрактное, чем традиционное программирование. Эта технология является по существу прагматическим воплощением к 1980 году идеи абстрактных типов данных как идеальной основы в программной индустрии в наше время.</p>
<p>Появление объектно-ориентированного метода произошло на основе всего предыдущего развития методов разработки ПО, а также других отраслей науки (развитие вычислительной техники, построение функционально и объектно-ориентированных операционных систем, достижения в методологии программирования, развитие теории построения и моделирования систем управления базами данных (построение отношений между объектами), исследования в области систем с искусственным интеллектом (теория фреймов) позволили лучше осознать механизмы абстракции, развитие философии и теории познания, концепция образцов и шаблонов теории архитектуры и строительства).</p>
<p>Основные признаки характеризуют объектно-ориентированную технологию программирования:</p>
<ol>
	<li><b><i>Абстракция</i></b>. Абстрагирование — это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция — это набор всех таких характеристик.</li>
	<li><b><i>Инкапсуляция</i></b>. Инкапсуляция — это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе, и скрыть детали реализации от пользователя.</li>
	<li><b><i>Наследование</i></b>. Наследование — это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником или производным классом.</li>
	<li><b><i>Полиморфизм</i></b>. Полиморфизм — это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</li>
	<li><b><i>Класс</i></b>. Класс является описываемой на языке терминологии (пространства имён) исходного кода моделью ещё не существующей сущности (объекта). Фактически он описывает устройство объекта, являясь своего рода чертежом. Говорят, что объект — это <b>экземпляр </b>класса. При этом в некоторых исполняющих системах класс также может представляться некоторым объектом при выполнении программы посредством динамической идентификации типа данных. Обычно классы разрабатывают таким образом, чтобы их объекты соответствовали объектам предметной области.</li>
	<li><b><i>Объект</i></b>. Сущность в адресном пространстве вычислительной системы, появляющаяся при создании экземпляра класса или копирования прототипа (например, после запуска результатов компиляции и связывания исходного кода на выполнение).</li>
	<li><b><i>Прототип</i></b> — это объект-образец, по образу и подобию которого создаются другие объекты. Объекты-копии могут сохранять связь с родительским объектом, автоматически наследуя изменения в прототипе; эта особенность определяется в рамках конкретного языка.</li>
</ol>
<p>Первым «настоящим» объектно-ориентированным языком программирования принято считать Смолтолк, разработанный в лаборатории компании Ксерокс. Затем появились и другие ОО языки (Си++, Паскаль, CLOS, Эйффель, Java и др.).</p>
<p>В качестве критерия применимости ООП можно использовать количество выделенных абстрактных типов с общими свойствами таких, что эта общность может быть использована в механизме наследования свойств. Однако поиск общих свойств среди типов далеко не тривиальный процесс. Он требует от разработчика системного склада мышления. Во время проектирования системы общность должна быть все время перед глазами, как при спецификации классов, так и при анализе того, обладают ли классы общими свойствами. Если общих свойств не находится, абстракция данных теряет смысл. Снижается эффективность и применения ООП.</p>
<p>ООП ориентировано на разработку крупных программных комплексов, разрабатываемых командой программистов (возможно, достаточно большой). Проектирование системы в целом, создание отдельных компонентов и их объединение в конечный продукт при этом часто выполняется разными людьми, и нет ни одного специалиста, который знал бы о проекте всё.</p>
<p>Объектно-ориентированное проектирование состоит в описании структуры и поведения проектируемой системы, то есть, фактически, в ответе на два основных вопроса:</p>
<p>- Из каких частей состоит система;</p>
<p>- В чём состоит ответственность каждой из частей.</p>
<p>Выделение частей производится таким образом, чтобы каждая имела минимальный по объёму и точно определённый набор выполняемых функций (обязанностей), и при этом взаимодействовала с другими частями как можно меньше.</p>
<p>Дальнейшее уточнение приводит к выделению более мелких фрагментов описания. По мере детализации описания и определения ответственности выявляются данные, которые необходимо хранить, наличие близких по поведению агентов, которые становятся кандидатами на реализацию в виде классов с общими предками.</p>
<p>После выделения компонентов и определения интерфейсов между ними реализация каждого компонента может проводиться практически независимо от остальных (разумеется, при соблюдении соответствующей технологической дисциплины).</p>
<p><b><i>Родственные методологии</i></b></p>
<p>Компонентное программирование — следующий этап развития ООП; прототип- и класс - ориентированное программирование — разные подходы к созданию программы, которые могут комбинироваться, имеющие свои преимущества и недостатки.</p>
<p><b><i>Компонентное программирование</i></b></p>
<p>Компонентно-ориентированное программирование — это своеобразная «надстройка» над ООП, набор правил и ограничений, направленных на построение крупных развивающихся программных систем с большим временем жизни. Программная система в этой методологии представляет собой набор компонентов с хорошо определёнными интерфейсами. Изменения в существующую систему вносятся путём создания новых компонентов в дополнение или в качестве замены ранее существующих. При создании новых компонентов на основе ранее созданных запрещено использование наследования реализации — новый компонент может наследовать лишь интерфейсы базового. Таким образом, компонентное программирование обходит проблему хрупкости базового класса.</p>
<p><b><i>Прототипное программирование</i></b></p>
<p>Прототипное программирование, сохранив часть черт ООП, отказалось от базовых понятий — класса и наследования.</p>
<p>- Вместо механизма описания классов и порождения экземпляров язык предоставляет механизм создания объекта (путём задания набора полей и методов, которые объект должен иметь) и механизм клонирования объектов.</p>
<p>- Каждый вновь созданный объект является «экземпляром без класса». Каждый объект может стать <i>прототипом </i>— быть использован для создания нового объекта с помощью операции <i>клонирования</i>. После клонирования новый объект может быть изменён, в частности, дополнен новыми полями и методами.</p>
<p>- Клонированный объект либо становится полной копией прототипа, хранящей все значения его полей и дублирующей его методы, либо сохраняет ссылку на прототип, не включая в себя клонированных полей и методов до тех пор, пока они не будут изменены. В последнем случае среда исполнения обеспечивает механизм <i>делегирования </i>— если при обращении к объекту он сам не содержит нужного метода или поля данных, вызов передаётся прототипу, от него, при необходимости — дальше по цепочке.</p>
<p><b><i>Класс - ориентированное программирование</i></b></p>
<p>Класс - ориентированное программирование — это программирование, сфокусированное на данных, причем данные и поведение неразрывно связаны между собой. Вместе данные и поведение представляют собой класс.</p>
<p>Соответственно в языках, основанных на понятии «класс», все объекты разделены на два основных типа — классы и экземпляры. Класс определяет структуру и функциональность (поведение), одинаковую для всех экземпляров данного класса. Экземпляр является носителем данных — то есть обладает состоянием, меняющимся в соответствии с поведением, заданным классом. В класс - ориентированных языках новый экземпляр создаётся через вызов конструктора класса (возможно, с набором параметров). Получившийся экземпляр имеет структуру и поведение, жёстко заданные его классом.</p>
<p><b><i>Объектно-ориентированные <a name="Объектно-ориентированные_языки_"></a>языки</i></b></p>
<p>Многие современные языки специально созданы для облегчения объектно-ориентированного программирования. Однако, следует отметить, что можно применять техники ООП и для не-объектно-ориентированного языка и наоборот, применение объектно-ориентированного языка вовсе не означает, что код автоматически становится объектно-ориентированным.</p>
<p>Как правило, объектно-ориентированный язык (ООЯ) содержит следующий набор элементов:</p>
<p>- Объявление классов с полями (данными — членами класса) и методами (функциями — членами класса).</p>
<p>- Механизм расширения класса (наследования) — порождение нового класса от существующего с автоматическим включением всех особенностей реализации класса-предка в состав класса-потомка. Большинство ООЯ поддерживают только единичное наследование.</p>
<p>- Полиморфные переменные и параметры функций (методов), позволяющие присваивать одной и той же переменной экземпляры различных классов.</p>
<p>- Полиморфное поведение экземпляров классов за счёт использования виртуальных методов. В некоторых ООЯ все методы классов являются виртуальными.</p>
<p>Некоторые языки добавляют к указанному минимальному набору те или иные дополнительные средства. В их числе:</p>
<p>- Конструкторы, деструкторы, финализаторы.</p>
<p>- Свойства (аксессоры).</p>
<p>- Индексаторы.</p>
<p>- Средства управления видимостью компонентов классов (интерфейсы или модификаторы доступа, такие как public, private, protected, feature и др.).</p>
 Одни языки отвечают принципам ООП в полной мере — в них все основные элементы являются объектами, имеющими состояние и связанные методы. Примеры подобных языков — <a href="http://ru.wikipedia.org/w/index.php?title=Smalltalk">Smalltalk,</a> <a href="http://ru.wikipedia.org/w/index.php?title=Eiffel">Eiffel.</a> Существуют<a name="Ссылки_"></a><a name="Литература_"></a><a name="Примечания_"></a> гибридные языки, совмещающие объектную подсистему в целостном виде с подсистемами других парадигм как «два и более языка в одном», позволяющие совмещать в одной программе объектные модели с иными, и размывающие грань между объектно-ориентированной и другими парадигмами за счёт нестандартных возможностей, балансирующих между ООП и другими парадигмами (таких как <a href="http://ru.wikipedia.org/w/index.php?title=%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B4%D0%B8%D1%81%D0%BF%D0%B5%D1%82%D1%87%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">множественная</a> <a href="http://ru.wikipedia.org/w/index.php?title=%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B4%D0%B8%D1%81%D0%BF%D0%B5%D1%82%D1%87%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">диспетчеризация</a>, параметрические классы, возможность манипулировать методами классов как самостоятельными объектами, и др.). Примеры таких языков: <a href="http://ru.wikipedia.org/w/index.php?title=CLOS">CLOS</a>, <a href="http://ru.wikipedia.org/w/index.php?title=Dylan_%28%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29">Dylan</a>, <a href="http://ru.wikipedia.org/w/index.php?title=OCaml">OCaml</a>, <a href="http://ru.wikipedia.org/w/index.php?title=Python">Python</a>, <a href="http://ru.wikipedia.org/w/index.php?title=Ruby">Ruby</a>, <a href="http://ru.wikipedia.org/w/index.php?title=Objective-C">Objective-C</a>. Однако, наиболее распространены языки, включающие средства эмуляции объектной модели поверх более традиционной императивной семантики. <a href="http://ru.wikipedia.org/w/index.php?title=%D0%9A%D1%8D%D0%B9%2C_%D0%90%D0%BB%D0%B0%D0%BD_%D0%9A%D1%83%D1%80%D1%82%D0%B8%D1%81">Алан Кэй</a> назвал такие языки «склеиванием возможностей» (<a href="http://ru.wikipedia.org/w/index.php?title=%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> <i>agglutination of features</i>) в противовес «чистоте стиля» (<a href="http://ru.wikipedia.org/w/index.php?title=%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">англ.</a> <i>crystalization of style</i>) языков, воплощающих некую парадигму непосредственно. Примеры таких языков — <a href="http://ru.wikipedia.org/w/index.php?title=%D0%A1%D0%B8%D0%BC%D1%83%D0%BB%D0%B0">Симула,</a> <a href="http://ru.wikipedia.org/w/index.php?title=C%2B%2B">C++,</a> <a href="http://ru.wikipedia.org/w/index.php?title=Visual_Basic">Visual Basic,</a> <a href="http://ru.wikipedia.org/w/index.php?title=Delphi_%28%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29">Delphi</a>, <a href="http://ru.wikipedia.org/w/index.php?title=%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B0">Модула</a>, <a href="http://ru.wikipedia.org/w/index.php?title=%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D0%B0-2">Модула-2</a>, <a href="http://ru.wikipedia.org/w/index.php?title=Java">Java</a>, <a href="http://ru.wikipedia.org/w/index.php?title=C_Sharp">C#</a>, <a href="http://ru.wikipedia.org/w/index.php?title=PHP">PHP</a>.



						</div>
  </div>
  <div id="panel2" class="tab-pane fade">
    <script type="text/javascript" language="JavaScript">// <![CDATA[
 var res="13441"; 
function check_me()
{
    var count=0;
    with(document.test) {
if (!Q1[0].checked&&!Q1[1].checked&&!Q1[2].checked&&!Q1[3].checked)  
{count+=1};  
if (!Q2[0].checked&&!Q2[1].checked&&!Q2[2].checked&&!Q2[3].checked)  
{count+=1};  
if (!Q3[0].checked&&!Q3[1].checked&&!Q3[2].checked&&!Q3[3].checked)  
{count+=1};  
if (!Q4[0].checked&&!Q4[1].checked&&!Q4[2].checked&&!Q4[3].checked)  
{count+=1};  
if (!Q5[0].checked&&!Q5[1].checked&&!Q5[2].checked&&!Q5[3].checked)  
{count+=1};  
if (count>0) alert("Вы выполнили не все задания. Проверьте себя!")    
        else answer();
    }
} 
 
function control(k, f1,f2,f3,f4,f5) {
if (k==1&&f1.checked) return true;
if (k==2&&f2.checked) return true;
if (k==3&&f3.checked) return true;
if (k==4&&f4.checked) return true;
if (k==5&&f5.checked) return true;
return false;
}

function answer() {
answ="";
     with(document)    {
    answ+=control(res.charAt(0) ,test.Q1[0],test.Q1[1],test.Q1[2],test.Q1[3])?"1":"0";
answ+=control(res.charAt(1) ,test.Q2[0],test.Q2[1],test.Q2[2],test.Q2[3])?"1":"0";
answ+=control(res.charAt(2) ,test.Q3[0],test.Q3[1],test.Q3[2],test.Q3[3])?"1":"0";
answ+=control(res.charAt(3) ,test.Q4[0],test.Q4[1],test.Q4[2],test.Q4[3])?"1":"0";
answ+=control(res.charAt(4) ,test.Q5[0],test.Q5[1],test.Q5[2],test.Q5[3])?"1":"0";

showResult();
    }
}
 
function showResult()   {
    var nok=0;
    var i,s;
 
for (i=0; i<answ.length;i++) {nok+=answ.charAt(i)=="1"?1:0;}
if(nok==5) s="ОТЛИЧНО";
if(nok<5) s="ХОРОШО";
if(nok<3.75) s="УДОВЛЕТВОРИТЕЛЬНО";
if (nok<2.5) s="НЕУДОВЛЕТВОРИТЕЛЬНО";
    document.test.s1.
    value="Количество правильных ответов "+nok+". Ваша оценка "+s+;
 
with(document.test)
    {
    if (answ.charAt(0)=="1") {T1.value=" + "} else {T1.value=" - "};
   if (answ.charAt(1)=="1") {T2.value=" + "} else {T2.value=" - "};
   if (answ.charAt(2)=="1") {T3.value=" + "} else {T3.value=" - "};
   if (answ.charAt(3)=="1") {T4.value=" + "} else {T4.value=" - "};
   if (answ.charAt(4)=="1") {T5.value=" + "} else {T5.value=" - "};
     }
}
function showhide(obj){
    if(obj == 'none') return 'inline';
    else return 'none';
}
// ]]>
</script>
<center><b>Тест.Понятие алгоритма</b></center><br/><br/>
&nbsp;&nbsp;&nbsp;<span style="color:#666666;text-decoration:underline;cursor:pointer;" onclick="document.getElementById('instruction').style.display = showhide(document.getElementById('instruction').style.display)">
Инструкция</span>
 <br/>
<div id="instruction" style="display: none; width: 100%;">
<ul>
<li>Выберите один из вариантов в каждом из 5 вопросов;</li>
<li>Нажмите на кнопку "Показать результат";</li>
<li>Скрипт не покажет результат, пока Вы не ответите на все вопросы;</li>
<li>Загляните в окно рядом с номером задания. Если ответ правильный, то там (+). Если Вы ошиблись, там (-).</li>
<li>За каждый правильный ответ начисляется 1 балл;</li>
<li>Оценки: менее 2.5 баллов - НЕУДОВЛЕТВОРИТЕЛЬНО, от 2.5 но менее 3.75 - УДОВЛЕТВОРИТЕЛЬНО, 3.75 и менее 5 - ХОРОШО, 5 - ОТЛИЧНО;</li>
<li>Чтобы сбросить результат тестирования, нажать кнопку "Сбросить ответы";</li>
</ul>
</div>
<form name="test"><ol>
<li><b> Алгоритм – ...</b><br/>
<input type="radio" value="0" name="Q1"/> Описание некоторой последовательности действий, приводящее к решению поставленной задачи.<br />
<input type="radio" value="1" name="Q1"/> Комбинация компьютерных инструкций и данных, позволяющая аппаратному обеспечению вычислительной системы выполнять вычисления или функции управления<br />
<input type="radio" value="2" name="Q1"/> Процесс и искусство создания компьютерных программ с помощью языков программирования<br />
<input type="radio" value="3" name="Q1"/> Быстрая «черновая» реализация базовой функциональности для анализа работы системы в целом<br />
<br/></li><li><b> Что относится к основным свойствам алгоритма</b><br/>
<input type="radio" value="0" name="Q2"/> Простота<br />
<input type="radio" value="1" name="Q2"/> Рентабельность<br />
<input type="radio" value="2" name="Q2"/> Дискретность<br />
<input type="radio" value="3" name="Q2"/> Унификация<br />
<br/></li><li><b> Что такое алгоритмизация</b><br/>
<input type="radio" value="0" name="Q3"/> Последовательность алгоритмов<br />
<input type="radio" value="1" name="Q3"/> Комбинация компьютерных инструкций и данных<br />
<input type="radio" value="2" name="Q3"/> Сложное цифровое устройство <br />
<input type="radio" value="3" name="Q3"/> Процесс составления алгоритмов<br />
<br/></li><li><b> Данные – ...</b><br/>
<input type="radio" value="0" name="Q4"/> Разрабатываемая программа<br />
<input type="radio" value="1" name="Q4"/> Электронно-вычислительная машина (ЭВМ).<br />
<input type="radio" value="2" name="Q4"/> Совокупность последовательных шагов, схема действий, приводящих к желаемому результату.<br />
<input type="radio" value="3" name="Q4"/> Любая информация, представленная в формализованном виде и пригодная для обработки алгоритмом.<br />
<br/></li><li><b> Свойство любой велечены</b><br/>
<input type="radio" value="0" name="Q5"/> Имя<br />
<input type="radio" value="1" name="Q5"/> Простота<br />
<input type="radio" value="2" name="Q5"/> Универсальность<br />
<input type="radio" value="3" name="Q5"/> Окупаемость<br />
<br/></li></ol>      
<CENTER>
<P><TEXTAREA name="s1" rows="4" cols="70" readonly> </TEXTAREA> </P>
<INPUT onclick="check_me()" type="button" value="Показать результат"/>&nbsp;&nbsp;&nbsp;&nbsp; 
<INPUT type="reset" value="Сбросить ответы"/> 
</CENTER>        
</form> 
						</div>
						<!-- /blog post -->
</p>
  </div>
  <a href="blog-post3.html" class="pagination-back pull-left">Назад</a>
  <a href="blog-post5.html" class="pagination-next pull-right">Далее</a>
  
</div>

					

					

						
					</div>
					<!-- /main blog -->

					<!-- aside blog -->
					<div id="aside" class="col-md-3">

						

						

						

					</div>
					<!-- /aside blog -->

				</div>
				<!-- row -->

			</div>
			<!-- container -->

		</div>
		<!-- /Blog -->

		<!-- Footer -->
		<footer id="footer" class="section">

			<!-- container -->
			<div class="container">

				<!-- row -->
				<div class="row">

					<!-- footer logo -->
					<div class="col-md-6">
						<div class="footer-logo">
							<a class="logo" href="index.html">
								<img src="./img/logo.png" alt="logo">
							</a>
						</div>
					</div>
					<!-- footer logo -->

				

				</div>
				<!-- /row -->

				<!-- row -->
				<div id="bottom-footer" class="row">

					

					

				</div>
				<!-- row -->

			</div>
			<!-- /container -->

		</footer>
		<!-- /Footer -->

		<!-- preloader -->
		<div id='preloader'><div class='preloader'></div></div>
		<!-- /preloader -->


		<!-- jQuery Plugins -->
		<script type="text/javascript" src="js/jquery.min.js"></script>
		<script type="text/javascript" src="js/bootstrap.min.js"></script>
		<script type="text/javascript" src="js/main.js"></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
 
<script type="text/javascript">
 
$(function() {
 
$(window).scroll(function() {
 
if($(this).scrollTop() != 0) {
 
$('#toTop').fadeIn();
 
} else {
 
$('#toTop').fadeOut();
 
}
 
});
 
$('#toTop').click(function() {
 
$('body,html').animate({scrollTop:0},800);
 
});
 
});
 
</script>
<div id = "toTop" >  Наверх </div>
	</body>
</html>
